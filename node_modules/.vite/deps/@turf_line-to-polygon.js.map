{
  "version": 3,
  "sources": ["../../@turf/bbox/index.ts", "../../@turf/invariant/index.ts", "../../@turf/clone/index.ts", "../../@turf/line-to-polygon/index.ts"],
  "sourcesContent": ["import { BBox } from \"geojson\";\nimport { AllGeoJSON } from \"@turf/helpers\";\nimport { coordEach } from \"@turf/meta\";\n\n/**\n * Calculates the bounding box for any GeoJSON object, including FeatureCollection.\n * Uses geojson.bbox if available and options.recompute is not set.\n *\n * @function\n * @param {GeoJSON} geojson any GeoJSON object\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.recompute] Whether to ignore an existing bbox property on geojson\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(\n  geojson: AllGeoJSON,\n  options: {\n    recompute?: boolean;\n  } = {}\n): BBox {\n  if (geojson.bbox != null && true !== options.recompute) {\n    return geojson.bbox;\n  }\n  const result: BBox = [Infinity, Infinity, -Infinity, -Infinity];\n  coordEach(geojson, (coord) => {\n    if (result[0] > coord[0]) {\n      result[0] = coord[0];\n    }\n    if (result[1] > coord[1]) {\n      result[1] = coord[1];\n    }\n    if (result[2] < coord[0]) {\n      result[2] = coord[0];\n    }\n    if (result[3] < coord[1]) {\n      result[3] = coord[1];\n    }\n  });\n  return result;\n}\n\nexport { bbox };\nexport default bbox;\n", "import {\n  Feature,\n  FeatureCollection,\n  Geometry,\n  LineString,\n  MultiPoint,\n  MultiLineString,\n  MultiPolygon,\n  Point,\n  Polygon,\n} from \"geojson\";\nimport { isNumber } from \"@turf/helpers\";\n\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @function\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(coord: Feature<Point> | Point | number[]): number[] {\n  if (!coord) {\n    throw new Error(\"coord is required\");\n  }\n\n  if (!Array.isArray(coord)) {\n    if (\n      coord.type === \"Feature\" &&\n      coord.geometry !== null &&\n      coord.geometry.type === \"Point\"\n    ) {\n      return [...coord.geometry.coordinates];\n    }\n    if (coord.type === \"Point\") {\n      return [...coord.coordinates];\n    }\n  }\n  if (\n    Array.isArray(coord) &&\n    coord.length >= 2 &&\n    !Array.isArray(coord[0]) &&\n    !Array.isArray(coord[1])\n  ) {\n    return [...coord];\n  }\n\n  throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @function\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords<\n  G extends\n    | Point\n    | LineString\n    | Polygon\n    | MultiPoint\n    | MultiLineString\n    | MultiPolygon,\n>(coords: any[] | Feature<G> | G): any[] {\n  if (Array.isArray(coords)) {\n    return coords;\n  }\n\n  // Feature\n  if (coords.type === \"Feature\") {\n    if (coords.geometry !== null) {\n      return coords.geometry.coordinates;\n    }\n  } else {\n    // Geometry\n    if (coords.coordinates) {\n      return coords.coordinates;\n    }\n  }\n\n  throw new Error(\n    \"coords must be GeoJSON Feature, Geometry Object or an Array\"\n  );\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @function\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates: any[]): boolean {\n  if (\n    coordinates.length > 1 &&\n    isNumber(coordinates[0]) &&\n    isNumber(coordinates[1])\n  ) {\n    return true;\n  }\n\n  if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n    return containsNumber(coordinates[0]);\n  }\n  throw new Error(\"coordinates must only contain numbers\");\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @function\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value: any, type: string, name: string): void {\n  if (!type || !name) {\n    throw new Error(\"type and name required\");\n  }\n\n  if (!value || value.type !== type) {\n    throw new Error(\n      \"Invalid input to \" +\n        name +\n        \": must be a \" +\n        type +\n        \", given \" +\n        value.type\n    );\n  }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @function\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature: Feature<any>, type: string, name: string): void {\n  if (!feature) {\n    throw new Error(\"No feature passed\");\n  }\n  if (!name) {\n    throw new Error(\".featureOf() requires a name\");\n  }\n  if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n    throw new Error(\n      \"Invalid input to \" + name + \", Feature with geometry required\"\n    );\n  }\n  if (!feature.geometry || feature.geometry.type !== type) {\n    throw new Error(\n      \"Invalid input to \" +\n        name +\n        \": must be a \" +\n        type +\n        \", given \" +\n        feature.geometry.type\n    );\n  }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @function\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(\n  featureCollection: FeatureCollection<any>,\n  type: string,\n  name: string\n) {\n  if (!featureCollection) {\n    throw new Error(\"No featureCollection passed\");\n  }\n  if (!name) {\n    throw new Error(\".collectionOf() requires a name\");\n  }\n  if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n    throw new Error(\n      \"Invalid input to \" + name + \", FeatureCollection required\"\n    );\n  }\n  for (const feature of featureCollection.features) {\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n      throw new Error(\n        \"Invalid input to \" + name + \", Feature with geometry required\"\n      );\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n      throw new Error(\n        \"Invalid input to \" +\n          name +\n          \": must be a \" +\n          type +\n          \", given \" +\n          feature.geometry.type\n      );\n    }\n  }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom<G extends Geometry>(geojson: Feature<G> | G): G {\n  if (geojson.type === \"Feature\") {\n    return geojson.geometry;\n  }\n  return geojson;\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nfunction getType(\n  geojson: Feature<any> | FeatureCollection<any> | Geometry,\n  _name?: string\n): string {\n  if (geojson.type === \"FeatureCollection\") {\n    return \"FeatureCollection\";\n  }\n  if (geojson.type === \"GeometryCollection\") {\n    return \"GeometryCollection\";\n  }\n  if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n    return geojson.geometry.type;\n  }\n  return geojson.type;\n}\n\nexport {\n  getCoord,\n  getCoords,\n  containsNumber,\n  geojsonType,\n  featureOf,\n  collectionOf,\n  getGeom,\n  getType,\n};\n// No default export!\n", "import { Feature, GeoJsonProperties } from \"geojson\";\nimport { AllGeoJSON } from \"@turf/helpers\";\n\n/**\n * Returns a cloned copy of the passed GeoJSON Object, including possible 'Foreign Members'.\n * ~3-5x faster than the common JSON.parse + JSON.stringify combo method.\n *\n * @function\n * @param {GeoJSON} geojson GeoJSON Object\n * @returns {GeoJSON} cloned GeoJSON Object\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]], {color: 'red'});\n *\n * var lineCloned = turf.clone(line);\n */\nfunction clone<T extends AllGeoJSON>(geojson: T): T {\n  if (!geojson) {\n    throw new Error(\"geojson is required\");\n  }\n\n  switch (geojson.type) {\n    case \"Feature\":\n      return cloneFeature(geojson);\n    case \"FeatureCollection\":\n      return cloneFeatureCollection(geojson);\n    case \"Point\":\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiPoint\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n    case \"GeometryCollection\":\n      return cloneGeometry(geojson);\n    default:\n      throw new Error(\"unknown GeoJSON type\");\n  }\n}\n\n/**\n * Clone Feature\n *\n * @private\n * @param {Feature<any>} geojson GeoJSON Feature\n * @returns {Feature<any>} cloned Feature\n */\nfunction cloneFeature(geojson: any) {\n  const cloned: any = { type: \"Feature\" };\n  // Preserve Foreign Members\n  Object.keys(geojson).forEach((key) => {\n    switch (key) {\n      case \"type\":\n      case \"properties\":\n      case \"geometry\":\n        return;\n      default:\n        cloned[key] = geojson[key];\n    }\n  });\n  // Add properties & geometry last\n  cloned.properties = cloneProperties(geojson.properties);\n  if (geojson.geometry == null) {\n    cloned.geometry = null;\n  } else {\n    cloned.geometry = cloneGeometry(geojson.geometry);\n  }\n  return cloned;\n}\n\n/**\n * Clone Properties\n *\n * @private\n * @param {Object} properties GeoJSON Properties\n * @returns {Object} cloned Properties\n */\nfunction cloneProperties(properties: GeoJsonProperties) {\n  const cloned: { [key: string]: any } = {};\n  if (!properties) {\n    return cloned;\n  }\n  Object.keys(properties).forEach((key) => {\n    const value = properties[key];\n    if (typeof value === \"object\") {\n      if (value === null) {\n        // handle null\n        cloned[key] = null;\n      } else if (Array.isArray(value)) {\n        // handle Array\n        cloned[key] = value.map((item) => {\n          return item;\n        });\n      } else {\n        // handle generic Object\n        cloned[key] = cloneProperties(value);\n      }\n    } else {\n      cloned[key] = value;\n    }\n  });\n  return cloned;\n}\n\n/**\n * Clone Feature Collection\n *\n * @private\n * @param {FeatureCollection<any>} geojson GeoJSON Feature Collection\n * @returns {FeatureCollection<any>} cloned Feature Collection\n */\nfunction cloneFeatureCollection(geojson: any) {\n  const cloned: any = { type: \"FeatureCollection\" };\n\n  // Preserve Foreign Members\n  Object.keys(geojson).forEach((key) => {\n    switch (key) {\n      case \"type\":\n      case \"features\":\n        return;\n      default:\n        cloned[key] = geojson[key];\n    }\n  });\n  // Add features\n  cloned.features = geojson.features.map((feature: Feature<any>) => {\n    return cloneFeature(feature);\n  });\n  return cloned;\n}\n\n/**\n * Clone Geometry\n *\n * @private\n * @param {Geometry<any>} geometry GeoJSON Geometry\n * @returns {Geometry<any>} cloned Geometry\n */\nfunction cloneGeometry(geometry: any) {\n  const geom: any = { type: geometry.type };\n  if (geometry.bbox) {\n    geom.bbox = geometry.bbox;\n  }\n\n  if (geometry.type === \"GeometryCollection\") {\n    geom.geometries = geometry.geometries.map((g: any) => {\n      return cloneGeometry(g);\n    });\n    return geom;\n  }\n  geom.coordinates = deepSlice(geometry.coordinates);\n  return geom;\n}\n\n/**\n * Deep Slice coordinates\n *\n * @private\n * @param {Coordinates} coords Coordinates\n * @returns {Coordinates} all coordinates sliced\n */\nfunction deepSlice<C = any[]>(coords: C): C {\n  const cloned: any = coords;\n  if (typeof cloned[0] !== \"object\") {\n    return cloned.slice();\n  }\n  return cloned.map((coord: any) => {\n    return deepSlice(coord);\n  });\n}\n\nexport { clone, cloneProperties };\nexport default clone;\n", "import {\n  Feature,\n  FeatureCollection,\n  MultiLineString,\n  LineString,\n  GeoJsonProperties,\n  BBox,\n  Position,\n} from \"geojson\";\nimport { bbox as turfBBox } from \"@turf/bbox\";\nimport { getCoords, getGeom } from \"@turf/invariant\";\nimport { polygon, multiPolygon, lineString } from \"@turf/helpers\";\nimport { clone } from \"@turf/clone\";\n\n/**\n * Converts (Multi)LineString(s) to Polygon(s).\n *\n * @function\n * @param {FeatureCollection|Feature<LineString|MultiLineString>} lines Features to convert\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] translates GeoJSON properties to Feature\n * @param {boolean} [options.autoComplete=true] auto complete linestrings (matches first & last coordinates)\n * @param {boolean} [options.orderCoords=true] sorts linestrings to place outer ring at the first position of the coordinates\n * @param {boolean} [options.mutate=false] mutate the original linestring using autoComplete (matches first & last coordinates)\n * @returns {Feature<Polygon|MultiPolygon>} converted to Polygons\n * @example\n * var line = turf.lineString([[125, -30], [145, -30], [145, -20], [125, -20], [125, -30]]);\n *\n * var polygon = turf.lineToPolygon(line);\n *\n * //addToMap\n * var addToMap = [polygon];\n */\nfunction lineToPolygon<G extends LineString | MultiLineString>(\n  lines: Feature<G> | FeatureCollection<G> | G,\n  options: {\n    properties?: GeoJsonProperties;\n    autoComplete?: boolean;\n    orderCoords?: boolean;\n    mutate?: boolean;\n  } = {}\n) {\n  // Optional parameters\n  var properties = options.properties;\n  var autoComplete = options.autoComplete ?? true;\n  var orderCoords = options.orderCoords ?? true;\n  var mutate = options.mutate ?? false;\n\n  if (!mutate) {\n    lines = clone(lines);\n  }\n\n  switch (lines.type) {\n    case \"FeatureCollection\":\n      var coords: number[][][][] = [];\n      lines.features.forEach(function (line) {\n        coords.push(\n          getCoords(lineStringToPolygon(line, {}, autoComplete, orderCoords))\n        );\n      });\n      return multiPolygon(coords, properties);\n    default:\n      return lineStringToPolygon(lines, properties, autoComplete, orderCoords);\n  }\n}\n\n/**\n * LineString to Polygon\n *\n * @private\n * @param {Feature<LineString|MultiLineString>} line line\n * @param {Object} [properties] translates GeoJSON properties to Feature\n * @param {boolean} [autoComplete=true] auto complete linestrings\n * @param {boolean} [orderCoords=true] sorts linestrings to place outer ring at the first position of the coordinates\n * @returns {Feature<Polygon>} line converted to Polygon\n */\nfunction lineStringToPolygon<G extends LineString | MultiLineString>(\n  line: Feature<G> | G,\n  properties: GeoJsonProperties | undefined,\n  autoComplete: boolean,\n  orderCoords: boolean\n) {\n  properties = properties\n    ? properties\n    : line.type === \"Feature\"\n      ? line.properties\n      : {};\n  var geom = getGeom(line);\n  var coords: Position[] | Position[][] = geom.coordinates;\n  var type = geom.type;\n\n  if (!coords.length) throw new Error(\"line must contain coordinates\");\n\n  switch (type) {\n    case \"LineString\":\n      if (autoComplete) coords = autoCompleteCoords(coords as Position[]);\n      return polygon([coords as Position[]], properties);\n    case \"MultiLineString\":\n      var multiCoords: number[][][] = [];\n      var largestArea = 0;\n\n      (coords as Position[][]).forEach(function (coord) {\n        if (autoComplete) coord = autoCompleteCoords(coord);\n\n        // Largest LineString to be placed in the first position of the coordinates array\n        if (orderCoords) {\n          var area = calculateArea(turfBBox(lineString(coord)));\n          if (area > largestArea) {\n            multiCoords.unshift(coord);\n            largestArea = area;\n          } else multiCoords.push(coord);\n        } else {\n          multiCoords.push(coord);\n        }\n      });\n      return polygon(multiCoords, properties);\n    default:\n      throw new Error(\"geometry type \" + type + \" is not supported\");\n  }\n}\n\n/**\n * Auto Complete Coords - matches first & last coordinates\n *\n * @private\n * @param {Array<Array<number>>} coords Coordinates\n * @returns {Array<Array<number>>} auto completed coordinates\n */\nfunction autoCompleteCoords(coords: Position[]) {\n  var first = coords[0];\n  var x1 = first[0];\n  var y1 = first[1];\n  var last = coords[coords.length - 1];\n  var x2 = last[0];\n  var y2 = last[1];\n  if (x1 !== x2 || y1 !== y2) {\n    coords.push(first);\n  }\n  return coords;\n}\n\n/**\n * area - quick approximate area calculation (used to sort)\n *\n * @private\n * @param {Array<number>} bbox BBox [west, south, east, north]\n * @returns {number} very quick area calculation\n */\nfunction calculateArea(bbox: BBox) {\n  var west = bbox[0];\n  var south = bbox[1];\n  var east = bbox[2];\n  var north = bbox[3];\n  return Math.abs(west - east) * Math.abs(south - north);\n}\n\nexport { lineToPolygon };\nexport default lineToPolygon;\n"],
  "mappings": "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",
  "names": ["bbox"]
}
